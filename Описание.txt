Этот проект представляет собой gRPC-сервер и клиент для управления сессиями оптимизации. Сервер сохраняет данные в памяти и создаёт текстовые файлы с переменными и их значениями. Клиент позволяет интерактивно управлять сессиями: создавать, оптимизировать и удалять их.

Используемые библиотеки
Для работы проекта используются следующие библиотеки:

grpc: Для реализации gRPC-сервера и клиента.

concurrent.futures: Для многопоточной обработки запросов на сервере.

os: Для работы с файловой системой (создание и удаление файлов).

traceback: Для обработки и вывода ошибок.

threading: Для реализации параллельного выполнения задач

Установка и запуск

Для .exe файлов:

Запустите сначала server, затем client, находящиеся в папке dist. Проект начнет работу.

При запуске вручную через терминал:

Установите зависимости:
Убедитесь, что у вас установлены необходимые библиотеки. Если нет, установите их с помощью pip:

pip install grpcio grpcio-tools

Запуск сервера:
Откройте терминал и запустите сервер:

python server.py

Сервер начнёт слушать на порту 5081.

Запуск клиента:
Откройте второй терминал и запустите клиент:

python client.py

Работа с клиентом
После запуска клиента появится меню с выбором методов:

Available methods:
1. Start
2. StartOptimise
3. Stop
4. Pause
5. Exit

Используемые форматы:

session_id - str
CVs, MVs - dict
constraints - dict (поправим потом тип, если нужно)
objectiveFunction - str, задающая математическое выражение в заданном формате
maxIterations - int
modelId - str


1. Метод Start

Перечень входных параметров задается в следующем виде: 
tagName="CV1", timeStamp=123456789, numericValue=10.5, где в tagName задается имя входных данных, timeStamp задается временным значением, 

Аналогично задаются значения MV

При выборе Start создаётся новая сессия.

Данные сессии сохраняются в памяти сервера.

Создаётся текстовый файл с переменными и их значениями.

Вы можете вызвать Start несколько раз подряд, чтобы создать несколько сессий.

2. Метод StartOptimise

Перечень входных параметров задается в следующем виде:
self, session_id, initialCVs, initialMVs, где initialCVs, initialMVs являются словарями (парой ключ-значение)

Обращение к конкретной сессии осуществляется с помощью идентификатора session_id

Сервер вернёт шаблонный ответ с результатами оптимизации: идентификатором сессии, значениями MV (текущими или лучшими в зависимости от флага), сообщением о результатах обработки

Возможен запуск нескольких потоков оптимизации параллельно.

Также используется для продолжения вычислений после орстановки сессии.

3. Метод Stop

Обращение к конкретной сессии осуществляется с помощью идентификатора session_id

Данные выбранной сессии будут удалены из памяти.

Текстовый файл, соответствующий сессии, будет удалён. Получаемым является только сообщение о результате в формате строки

4. Метод Pause

Обращение к конкретной сессии осуществляется с помощью идентификатора session_id.

Оптимизация останавливается на достигнутой итерации и остается в памяти

Возвращается сообщение о результате (строка) и флаг успешной паузы

5. Метод Exit

При выборе Exit клиент завершает работу.


6. Также необходима реализация на стороне сервера DataProcessing метода CalculateCV, принимающего идентификатор сессии, идентификатор модели, и значения MV в формате словаря

Результатом работы метода должен быть ответ, содержащий: идентификатор сессии, новые значения CV (словарь), сообщение о результатах (string)

7. Метод Targetfreq 
- Отправляемые данные:
  - session_id (str): Идентификатор сессии, для которой запрашивается целевая функция.

- Получаемые данные:
  - objectiveFunction (str): Целевая функция в виде строки, где переменные обозначаются как [CV] и [MV] (CV и MV — названия переменных). Строка уже включает необходимые математические операции (+, -, *, /, ^).

Строка с целевой функцией передаётся в запросе уже в необходимом формате. Пример: "[CV1]*[CV2]^2-3/[CV3]" 


Новая функция статуса сервиса:


1.Принцип работы:

Клиент отправляет запрос ArgRequest (пока только с пустым accessToken)

Сервер возвращает ответ ServiceStatus с фиксированными значениями:

return RtoApi_pb2.ServiceStatus(
    serviceId="",
    status="Running",
    serviceType="RtoService", 
    user="",
    message=""
)


2.Где реализовано:


В серверном коде как метод класса DataProcessingServiceServicer

В клиенте как метод get_service_status()


3.Зачем нужна эта функция:

Health-check:

Позволяет клиентам проверять, жив ли сервер

Аналог "пингования" сервиса


4.Базовый мониторинг:

Можно определить тип сервиса (RtoService)

Видеть его текущее состояние (Running/Stopped)


5.Расширяемость:

Поле serviceId можно использовать для кластеров

user - для аутентифицированных сессий

message - для передачи служебной информации


6.Интеграция:

Стандартная практика в микросервисной архитектуре

Позволяет оркестраторам (Kubernetes) проверять состояние сервиса
